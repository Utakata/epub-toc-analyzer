#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
EPUB目次解析ツール GUI版 v3.0
分割機能、動的TOC解析、マルチフォーマット出力対応
"""

import sys
import os
import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
from pathlib import Path
import threading
import queue
import json
from datetime import datetime

# ドラッグ&ドロップサポート
try:
    from tkinterdnd2 import DND_FILES, TkinterDnD
    DND_SUPPORT = True
except ImportError:
    DND_SUPPORT = False

# v2.0モジュールをインポート
try:
    from epubsplit_word_toc_v2 import SplitEpubWordTOC, BatchProcessor
    V2_SUPPORT = True
except ImportError:
    V2_SUPPORT = False

# v3.0モジュールをインポート
try:
    from split_engine_v3 import (
        DynamicTOCAnalyzer, WordDocumentSplitter, MultiFormatExporter,
        SplitConfig, TOCEntry, WORD_SUPPORT, PDF_SUPPORT, EPUB_SUPPORT
    )
    V3_SUPPORT = True
except ImportError:
    V3_SUPPORT = False

class EpubTocGUIv3:
    """EPUB目次解析ツール GUI版 v3.0"""
    
    def __init__(self, root):
        self.root = root
        self.root.title("📚 EPUB目次解析ツール v3.0 - 分割機能対応")
        self.root.geometry("900x800")
        self.root.configure(bg='#f0f0f0')
        
        # 変数
        self.processing = False
        self.queue = queue.Queue()
        self.batch_processor = None
        self.analyzer = None
        self.analysis_report = None
        
        # スタイル設定
        self.setup_styles()
        
        # GUI作成
        self.create_widgets()
        
        # ドラッグ&ドロップ設定
        if DND_SUPPORT:
            self.setup_drag_drop()
        
        # キューチェック開始
        self.check_queue()
    
    def setup_styles(self):
        """スタイル設定"""
        style = ttk.Style()
        style.theme_use('clam')
        
        # カスタムスタイル
        style.configure('Title.TLabel', font=('Arial', 16, 'bold'), foreground='#2c5aa0')
        style.configure('Header.TLabel', font=('Arial', 12, 'bold'), foreground='#444444')
        style.configure('Status.TLabel', font=('Arial', 10), foreground='#666666')
        style.configure('Success.TLabel', font=('Arial', 10), foreground='#0a7029')
        style.configure('Error.TLabel', font=('Arial', 10), foreground='#d32f2f')
    
    def create_widgets(self):
        """ウィジェット作成"""
        # メインフレーム
        main_frame = ttk.Frame(self.root, padding="20")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # タイトル
        title_label = ttk.Label(main_frame, 
                               text="📚 EPUB目次解析ツール v3.0", 
                               style='Title.TLabel')
        title_label.grid(row=0, column=0, columnspan=4, pady=(0, 20))
        
        # 機能選択タブ
        self.notebook = ttk.Notebook(main_frame)
        self.notebook.grid(row=1, column=0, columnspan=4, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 15))
        
        # タブ1: 目次解析
        self.create_analysis_tab()
        
        # タブ2: 分割機能
        self.create_split_tab()
        
        # タブ3: バッチ処理
        self.create_batch_tab()
        
        # 実行ボタンエリア
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=2, column=0, columnspan=4, pady=(0, 15))\n        \n        self.process_button = ttk.Button(button_frame, text="🚀 実行", \n                                        command=self.start_processing, \n                                        style='Accent.TButton')\n        self.process_button.pack(side=tk.LEFT, padx=(0, 10))\n        \n        self.stop_button = ttk.Button(button_frame, text=\"⏹ 停止\", \n                                     command=self.stop_processing, \n                                     state='disabled')\n        self.stop_button.pack(side=tk.LEFT)\n        \n        # プログレスバー\n        self.progress = ttk.Progressbar(main_frame, mode='indeterminate')\n        self.progress.grid(row=3, column=0, columnspan=4, sticky=(tk.W, tk.E), pady=(0, 10))\n        \n        # ステータス\n        self.status_var = tk.StringVar(value=\"Ready\")\n        status_label = ttk.Label(main_frame, textvariable=self.status_var, style='Status.TLabel')\n        status_label.grid(row=4, column=0, columnspan=4)\n        \n        # ログエリア\n        log_frame = ttk.LabelFrame(main_frame, text=\"処理ログ\", padding=\"10\")\n        log_frame.grid(row=5, column=0, columnspan=4, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(15, 0))\n        \n        self.log_text = scrolledtext.ScrolledText(log_frame, width=100, height=15, \n                                                 font=('Consolas', 9))\n        self.log_text.pack(fill=tk.BOTH, expand=True)\n        \n        # グリッドの重みを設定\n        self.root.columnconfigure(0, weight=1)\n        self.root.rowconfigure(0, weight=1)\n        main_frame.columnconfigure(1, weight=1)\n        main_frame.rowconfigure(1, weight=1)\n    \n    def create_analysis_tab(self):\n        \"\"\"目次解析タブを作成\"\"\"\n        analysis_frame = ttk.Frame(self.notebook, padding=\"10\")\n        self.notebook.add(analysis_frame, text=\"📊 目次解析\")\n        \n        # ファイル選択\n        file_frame = ttk.LabelFrame(analysis_frame, text=\"ファイル選択\", padding=\"10\")\n        file_frame.grid(row=0, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 15))\n        \n        self.analysis_file_var = tk.StringVar()\n        file_entry = ttk.Entry(file_frame, textvariable=self.analysis_file_var, width=70)\n        file_entry.grid(row=0, column=0, padx=(0, 10))\n        \n        browse_btn = ttk.Button(file_frame, text=\"参照\", command=self.browse_analysis_file)\n        browse_btn.grid(row=0, column=1)\n        \n        # ファイル種別選択\n        type_frame = ttk.LabelFrame(analysis_frame, text=\"ファイル種別\", padding=\"10\")\n        type_frame.grid(row=1, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 15))\n        \n        self.file_type_var = tk.StringVar(value=\"auto\")\n        auto_radio = ttk.Radiobutton(type_frame, text=\"自動判定\", \n                                    variable=self.file_type_var, value=\"auto\")\n        auto_radio.grid(row=0, column=0, padx=(0, 20))\n        \n        word_radio = ttk.Radiobutton(type_frame, text=\"Wordファイル(.docx)\", \n                                    variable=self.file_type_var, value=\"word\")\n        word_radio.grid(row=0, column=1, padx=(0, 20))\n        \n        epub_radio = ttk.Radiobutton(type_frame, text=\"EPUBファイル(.epub)\", \n                                    variable=self.file_type_var, value=\"epub\")\n        epub_radio.grid(row=0, column=2)\n        \n        # 解析結果表示エリア\n        result_frame = ttk.LabelFrame(analysis_frame, text=\"解析結果\", padding=\"10\")\n        result_frame.grid(row=2, column=0, columnspan=3, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 15))\n        \n        self.analysis_result_text = scrolledtext.ScrolledText(result_frame, width=80, height=15, \n                                                             font=('Consolas', 9))\n        self.analysis_result_text.pack(fill=tk.BOTH, expand=True)\n        \n        # 重みを設定\n        analysis_frame.columnconfigure(1, weight=1)\n        analysis_frame.rowconfigure(2, weight=1)\n    \n    def create_split_tab(self):\n        \"\"\"分割機能タブを作成\"\"\"\n        split_frame = ttk.Frame(self.notebook, padding=\"10\")\n        self.notebook.add(split_frame, text=\"✂️ 分割機能\")\n        \n        # 分割設定\n        config_frame = ttk.LabelFrame(split_frame, text=\"分割設定\", padding=\"10\")\n        config_frame.grid(row=0, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 15))\n        \n        # 分割レベル\n        ttk.Label(config_frame, text=\"分割レベル:\").grid(row=0, column=0, sticky=tk.W)\n        self.split_level_var = tk.StringVar(value=\"1\")\n        level_combo = ttk.Combobox(config_frame, textvariable=self.split_level_var, \n                                  values=[\"1\", \"2\", \"3\"], state=\"readonly\", width=10)\n        level_combo.grid(row=0, column=1, sticky=tk.W, padx=(10, 20))\n        \n        # 出力形式\n        ttk.Label(config_frame, text=\"出力形式:\").grid(row=0, column=2, sticky=tk.W)\n        self.split_format_var = tk.StringVar(value=\"word\")\n        format_combo = ttk.Combobox(config_frame, textvariable=self.split_format_var, \n                                   values=[\"word\", \"pdf\", \"epub\"], state=\"readonly\", width=15)\n        format_combo.grid(row=0, column=3, sticky=tk.W, padx=(10, 0))\n        \n        # 出力ディレクトリ\n        ttk.Label(config_frame, text=\"出力先:\").grid(row=1, column=0, sticky=tk.W, pady=(10, 0))\n        self.split_output_var = tk.StringVar(value=\"output_split\")\n        output_entry = ttk.Entry(config_frame, textvariable=self.split_output_var, width=50)\n        output_entry.grid(row=1, column=1, columnspan=2, sticky=(tk.W, tk.E), padx=(10, 10), pady=(10, 0))\n        \n        output_browse = ttk.Button(config_frame, text=\"参照\", command=self.browse_split_output)\n        output_browse.grid(row=1, column=3, pady=(10, 0))\n        \n        # 詳細オプション\n        option_frame = ttk.LabelFrame(split_frame, text=\"詳細オプション\", padding=\"10\")\n        option_frame.grid(row=1, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 15))\n        \n        self.preserve_formatting_var = tk.BooleanVar(value=True)\n        format_check = ttk.Checkbutton(option_frame, text=\"書式を保持\", \n                                      variable=self.preserve_formatting_var)\n        format_check.grid(row=0, column=0, sticky=tk.W)\n        \n        self.include_subsections_var = tk.BooleanVar(value=True)\n        subsection_check = ttk.Checkbutton(option_frame, text=\"下位レベルも含める\", \n                                          variable=self.include_subsections_var)\n        subsection_check.grid(row=0, column=1, sticky=tk.W, padx=(20, 0))\n        \n        # ファイル名パターン\n        ttk.Label(option_frame, text=\"ファイル名パターン:\").grid(row=1, column=0, sticky=tk.W, pady=(10, 0))\n        self.filename_pattern_var = tk.StringVar(value=\"{index:02d}_{title}\")\n        pattern_entry = ttk.Entry(option_frame, textvariable=self.filename_pattern_var, width=40)\n        pattern_entry.grid(row=1, column=1, sticky=tk.W, padx=(10, 0), pady=(10, 0))\n        \n        # 分割プレビュー\n        preview_frame = ttk.LabelFrame(split_frame, text=\"分割プレビュー\", padding=\"10\")\n        preview_frame.grid(row=2, column=0, columnspan=3, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 15))\n        \n        self.split_preview_text = scrolledtext.ScrolledText(preview_frame, width=80, height=12, \n                                                           font=('Consolas', 9))\n        self.split_preview_text.pack(fill=tk.BOTH, expand=True)\n        \n        # 重みを設定\n        split_frame.columnconfigure(1, weight=1)\n        split_frame.rowconfigure(2, weight=1)\n    \n    def create_batch_tab(self):\n        \"\"\"バッチ処理タブを作成\"\"\"\n        batch_frame = ttk.Frame(self.notebook, padding=\"10\")\n        self.notebook.add(batch_frame, text=\"🔄 バッチ処理\")\n        \n        # フォルダ選択\n        folder_frame = ttk.LabelFrame(batch_frame, text=\"フォルダ選択\", padding=\"10\")\n        folder_frame.grid(row=0, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 15))\n        \n        self.batch_folder_var = tk.StringVar()\n        folder_entry = ttk.Entry(folder_frame, textvariable=self.batch_folder_var, width=70)\n        folder_entry.grid(row=0, column=0, padx=(0, 10))\n        \n        folder_browse = ttk.Button(folder_frame, text=\"参照\", command=self.browse_batch_folder)\n        folder_browse.grid(row=0, column=1)\n        \n        # バッチ処理設定\n        batch_config_frame = ttk.LabelFrame(batch_frame, text=\"バッチ処理設定\", padding=\"10\")\n        batch_config_frame.grid(row=1, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 15))\n        \n        ttk.Label(batch_config_frame, text=\"並列実行数:\").grid(row=0, column=0, sticky=tk.W)\n        self.workers_var = tk.StringVar(value=\"4\")\n        workers_spin = ttk.Spinbox(batch_config_frame, from_=1, to=8, \n                                  textvariable=self.workers_var, width=10)\n        workers_spin.grid(row=0, column=1, sticky=tk.W, padx=(10, 20))\n        \n        self.recursive_var = tk.BooleanVar(value=True)\n        recursive_check = ttk.Checkbutton(batch_config_frame, text=\"サブフォルダも検索\", \n                                         variable=self.recursive_var)\n        recursive_check.grid(row=0, column=2, padx=(0, 20))\n        \n        # 処理種別\n        ttk.Label(batch_config_frame, text=\"処理種別:\").grid(row=1, column=0, sticky=tk.W, pady=(10, 0))\n        self.batch_mode_var = tk.StringVar(value=\"analysis\")\n        \n        analysis_radio = ttk.Radiobutton(batch_config_frame, text=\"目次解析のみ\", \n                                        variable=self.batch_mode_var, value=\"analysis\")\n        analysis_radio.grid(row=1, column=1, sticky=tk.W, padx=(10, 0), pady=(10, 0))\n        \n        split_radio = ttk.Radiobutton(batch_config_frame, text=\"分割処理も実行\", \n                                     variable=self.batch_mode_var, value=\"split\")\n        split_radio.grid(row=1, column=2, sticky=tk.W, pady=(10, 0))\n        \n        # バッチ結果\n        batch_result_frame = ttk.LabelFrame(batch_frame, text=\"バッチ処理結果\", padding=\"10\")\n        batch_result_frame.grid(row=2, column=0, columnspan=3, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 15))\n        \n        self.batch_result_text = scrolledtext.ScrolledText(batch_result_frame, width=80, height=12, \n                                                          font=('Consolas', 9))\n        self.batch_result_text.pack(fill=tk.BOTH, expand=True)\n        \n        # 重みを設定\n        batch_frame.columnconfigure(1, weight=1)\n        batch_frame.rowconfigure(2, weight=1)\n    \n    def setup_drag_drop(self):\n        \"\"\"ドラッグ&ドロップの設定\"\"\"\n        self.root.drop_target_register(DND_FILES)\n        self.root.dnd_bind('<<Drop>>', self.on_drop)\n    \n    def on_drop(self, event):\n        \"\"\"ドラッグ&ドロップ処理\"\"\"\n        files = self.root.tk.splitlist(event.data)\n        if files:\n            file_path = Path(files[0])\n            if file_path.is_file():\n                if file_path.suffix.lower() in ['.docx', '.epub']:\n                    # 現在のタブに応じてファイルを設定\n                    current_tab = self.notebook.index(self.notebook.select())\n                    if current_tab == 0:  # 目次解析タブ\n                        self.analysis_file_var.set(str(file_path))\n                    else:\n                        self.analysis_file_var.set(str(file_path))\n                else:\n                    messagebox.showwarning(\"警告\", \"WordファイルまたはEPUBファイルを選択してください\")\n            elif file_path.is_dir():\n                self.batch_folder_var.set(str(file_path))\n                self.notebook.select(2)  # バッチ処理タブに切り替え\n    \n    def browse_analysis_file(self):\n        \"\"\"解析ファイルの選択\"\"\"\n        file_path = filedialog.askopenfilename(\n            title=\"解析ファイルを選択\",\n            filetypes=[\n                (\"対応ファイル\", \"*.docx;*.epub\"),\n                (\"Word files\", \"*.docx\"), \n                (\"EPUB files\", \"*.epub\"), \n                (\"All files\", \"*.*\")\n            ]\n        )\n        if file_path:\n            self.analysis_file_var.set(file_path)\n    \n    def browse_split_output(self):\n        \"\"\"分割出力フォルダの選択\"\"\"\n        folder_path = filedialog.askdirectory(title=\"分割出力フォルダを選択\")\n        if folder_path:\n            self.split_output_var.set(folder_path)\n    \n    def browse_batch_folder(self):\n        \"\"\"バッチ処理フォルダの選択\"\"\"\n        folder_path = filedialog.askdirectory(title=\"バッチ処理フォルダを選択\")\n        if folder_path:\n            self.batch_folder_var.set(folder_path)\n    \n    def start_processing(self):\n        \"\"\"処理開始\"\"\"\n        if not V3_SUPPORT:\n            messagebox.showerror(\"エラー\", \"v3.0モジュールが利用できません\")\n            return\n        \n        current_tab = self.notebook.index(self.notebook.select())\n        \n        if current_tab == 0:  # 目次解析\n            self.start_analysis()\n        elif current_tab == 1:  # 分割機能\n            self.start_split()\n        elif current_tab == 2:  # バッチ処理\n            self.start_batch()\n    \n    def start_analysis(self):\n        \"\"\"目次解析開始\"\"\"\n        file_path = self.analysis_file_var.get().strip()\n        if not file_path or not Path(file_path).exists():\n            messagebox.showwarning(\"警告\", \"有効なファイルを選択してください\")\n            return\n        \n        self.set_processing_state(True)\n        self.log(\"🔍 目次解析を開始しています...\")\n        \n        # 別スレッドで解析実行\n        thread = threading.Thread(target=self.process_analysis, args=(file_path,), daemon=True)\n        thread.start()\n    \n    def start_split(self):\n        \"\"\"分割処理開始\"\"\"\n        if not self.analysis_report:\n            messagebox.showwarning(\"警告\", \"最初に目次解析を実行してください\")\n            self.notebook.select(0)  # 解析タブに切り替え\n            return\n        \n        self.set_processing_state(True)\n        self.log(\"✂️ 分割処理を開始しています...\")\n        \n        # 別スレッドで分割実行\n        thread = threading.Thread(target=self.process_split, daemon=True)\n        thread.start()\n    \n    def start_batch(self):\n        \"\"\"バッチ処理開始\"\"\"\n        folder_path = self.batch_folder_var.get().strip()\n        if not folder_path or not Path(folder_path).exists():\n            messagebox.showwarning(\"警告\", \"有効なフォルダを選択してください\")\n            return\n        \n        self.set_processing_state(True)\n        self.log(\"🔄 バッチ処理を開始しています...\")\n        \n        # 別スレッドでバッチ実行\n        thread = threading.Thread(target=self.process_batch, args=(folder_path,), daemon=True)\n        thread.start()\n    \n    def process_analysis(self, file_path):\n        \"\"\"目次解析処理（別スレッド）\"\"\"\n        try:\n            self.analyzer = DynamicTOCAnalyzer()\n            \n            # ファイル種別判定\n            file_type = self.file_type_var.get()\n            if file_type == \"auto\":\n                file_type = \"word\" if file_path.endswith('.docx') else \"epub\"\n            \n            self.queue.put((\"log\", f\"📁 ファイル: {Path(file_path).name}\"))\n            self.queue.put((\"log\", f\"📊 種別: {file_type.upper()}ファイル\"))\n            \n            # 解析実行\n            if file_type == \"word\":\n                self.analysis_report = self.analyzer.analyze_word_document(file_path)\n            else:\n                self.analysis_report = self.analyzer.analyze_epub_toc(file_path)\n            \n            # 結果表示\n            result_text = self.format_analysis_result(self.analysis_report)\n            self.queue.put((\"analysis_result\", result_text))\n            self.queue.put((\"log\", \"✅ 目次解析完了！\"))\n            self.queue.put((\"complete\", \"目次解析が完了しました\"))\n            \n        except Exception as e:\n            self.queue.put((\"error\", f\"解析エラー: {str(e)}\"))\n        finally:\n            self.queue.put((\"finished\", None))\n    \n    def process_split(self):\n        \"\"\"分割処理（別スレッド）\"\"\"\n        try:\n            file_path = self.analysis_file_var.get()\n            \n            # 分割設定作成\n            config = SplitConfig(\n                split_level=int(self.split_level_var.get()),\n                output_format=self.split_format_var.get(),\n                output_dir=self.split_output_var.get(),\n                filename_pattern=self.filename_pattern_var.get(),\n                preserve_formatting=self.preserve_formatting_var.get(),\n                include_subsections=self.include_subsections_var.get()\n            )\n            \n            self.queue.put((\"log\", f\"⚙️ 分割レベル: {config.split_level}\"))\n            self.queue.put((\"log\", f\"📄 出力形式: {config.output_format}\"))\n            self.queue.put((\"log\", f\"📁 出力先: {config.output_dir}\"))\n            \n            if config.output_format == \"word\":\n                # Word分割\n                splitter = WordDocumentSplitter(self.analyzer)\n                output_files = splitter.split_document(file_path, config)\n                \n                self.queue.put((\"log\", f\"✅ {len(output_files)}個のファイルを生成しました\"))\n                for i, file_path in enumerate(output_files, 1):\n                    self.queue.put((\"log\", f\"  {i}. {Path(file_path).name}\"))\n            \n            else:\n                # その他形式（PDF、EPUB）\n                self.queue.put((\"log\", \"🚧 PDF/EPUB出力は開発中です\"))\n            \n            self.queue.put((\"complete\", \"分割処理が完了しました\"))\n            \n        except Exception as e:\n            self.queue.put((\"error\", f\"分割エラー: {str(e)}\"))\n        finally:\n            self.queue.put((\"finished\", None))\n    \n    def process_batch(self, folder_path):\n        \"\"\"バッチ処理（別スレッド）\"\"\"\n        try:\n            self.queue.put((\"log\", f\"📁 処理フォルダ: {folder_path}\"))\n            \n            # 対応ファイルを検索\n            folder = Path(folder_path)\n            patterns = ['*.docx', '*.epub']\n            files = []\n            \n            for pattern in patterns:\n                if self.recursive_var.get():\n                    files.extend(folder.rglob(pattern))\n                else:\n                    files.extend(folder.glob(pattern))\n            \n            self.queue.put((\"log\", f\"📚 {len(files)}個のファイルを検出\"))\n            \n            if not files:\n                self.queue.put((\"error\", \"処理対象ファイルが見つかりません\"))\n                return\n            \n            # 各ファイルを処理\n            success_count = 0\n            error_count = 0\n            \n            for i, file_path in enumerate(files, 1):\n                try:\n                    self.queue.put((\"log\", f\"[{i}/{len(files)}] {file_path.name}\"))\n                    \n                    analyzer = DynamicTOCAnalyzer()\n                    if file_path.suffix.lower() == '.docx':\n                        report = analyzer.analyze_word_document(str(file_path))\n                    else:\n                        report = analyzer.analyze_epub_toc(str(file_path))\n                    \n                    self.queue.put((\"log\", f\"  📊 目次エントリ: {report['total_entries']}個\"))\n                    self.queue.put((\"log\", f\"  🎯 推奨分割レベル: {report['recommended_split_level']}\"))\n                    \n                    success_count += 1\n                    \n                except Exception as e:\n                    self.queue.put((\"log\", f\"  ❌ エラー: {str(e)}\"))\n                    error_count += 1\n            \n            self.queue.put((\"log\", f\"\\n📊 バッチ処理完了:\"))\n            self.queue.put((\"log\", f\"  ✅ 成功: {success_count}ファイル\"))\n            self.queue.put((\"log\", f\"  ❌ エラー: {error_count}ファイル\"))\n            \n            self.queue.put((\"complete\", f\"バッチ処理完了（{success_count}件成功）\"))\n            \n        except Exception as e:\n            self.queue.put((\"error\", f\"バッチ処理エラー: {str(e)}\"))\n        finally:\n            self.queue.put((\"finished\", None))\n    \n    def format_analysis_result(self, report):\n        \"\"\"解析結果のフォーマット\"\"\"\n        result = []\n        result.append(\"📊 目次構造解析結果\")\n        result.append(\"=\" * 50)\n        result.append(f\"総エントリ数: {report['total_entries']}個\")\n        result.append(f\"最大階層深度: {report['max_depth']}レベル\")\n        result.append(f\"推奨分割レベル: {report['recommended_split_level']}\")\n        result.append(\"\")\n        \n        result.append(\"📋 レベル別統計:\")\n        for level, count in report['level_stats'].items():\n            result.append(f\"  レベル{level}: {count}個\")\n        result.append(\"\")\n        \n        result.append(\"🔍 分割プレビュー:\")\n        for i, section in enumerate(report['split_preview'], 1):\n            result.append(f\"{i}. {section['title']}\")\n            if section['subsections'] > 0:\n                result.append(f\"   └ サブセクション: {section['subsections']}個\")\n                for sub in section['subsection_list']:\n                    result.append(f\"     • {sub}\")\n        \n        return \"\\n\".join(result)\n    \n    def stop_processing(self):\n        \"\"\"処理停止\"\"\"\n        self.processing = False\n        self.queue.put((\"log\", \"⏹ 処理を停止しました\"))\n        self.queue.put((\"finished\", None))\n    \n    def set_processing_state(self, processing):\n        \"\"\"処理状態の設定\"\"\"\n        self.processing = processing\n        if processing:\n            self.process_button.configure(state='disabled')\n            self.stop_button.configure(state='normal')\n            self.progress.configure(mode='indeterminate')\n            self.progress.start()\n            self.status_var.set(\"処理中...\")\n        else:\n            self.process_button.configure(state='normal')\n            self.stop_button.configure(state='disabled')\n            self.progress.stop()\n            self.progress.configure(mode='determinate', value=0)\n            self.status_var.set(\"Ready\")\n    \n    def check_queue(self):\n        \"\"\"キューチェック\"\"\"\n        try:\n            while True:\n                msg_type, msg_data = self.queue.get_nowait()\n                \n                if msg_type == \"log\":\n                    self.log(msg_data)\n                elif msg_type == \"analysis_result\":\n                    self.analysis_result_text.delete(1.0, tk.END)\n                    self.analysis_result_text.insert(tk.END, msg_data)\n                elif msg_type == \"complete\":\n                    self.status_var.set(msg_data)\n                    messagebox.showinfo(\"完了\", msg_data)\n                elif msg_type == \"error\":\n                    self.status_var.set(msg_data)\n                    messagebox.showerror(\"エラー\", msg_data)\n                elif msg_type == \"finished\":\n                    self.set_processing_state(False)\n                    break\n                    \n        except queue.Empty:\n            pass\n        \n        # 100ms後に再チェック\n        self.root.after(100, self.check_queue)\n    \n    def log(self, message):\n        \"\"\"ログ出力\"\"\"\n        timestamp = datetime.now().strftime(\"%H:%M:%S\")\n        log_message = f\"[{timestamp}] {message}\\n\"\n        self.log_text.insert(tk.END, log_message)\n        self.log_text.see(tk.END)\n        self.root.update_idletasks()\n\ndef main():\n    \"\"\"メイン関数\"\"\"\n    # Tkinterルートウィンドウを作成\n    if DND_SUPPORT:\n        root = TkinterDnD.Tk()\n    else:\n        root = tk.Tk()\n        print(\"⚠️ tkinterdnd2がインストールされていません。ドラッグ&ドロップは無効です。\")\n    \n    try:\n        # GUI作成\n        app = EpubTocGUIv3(root)\n        \n        # ウィンドウを中央に配置\n        root.update_idletasks()\n        x = (root.winfo_screenwidth() // 2) - (root.winfo_width() // 2)\n        y = (root.winfo_screenheight() // 2) - (root.winfo_height() // 2)\n        root.geometry(f\"+{x}+{y}\")\n        \n        # メインループ開始\n        root.mainloop()\n        \n    except Exception as e:\n        messagebox.showerror(\"起動エラー\", f\"アプリケーションの起動に失敗しました:\\n{str(e)}\")\n\nif __name__ == \"__main__\":\n    main()\n