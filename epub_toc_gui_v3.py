#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
EPUBç›®æ¬¡è§£æãƒ„ãƒ¼ãƒ« GUIç‰ˆ v3.0
åˆ†å‰²æ©Ÿèƒ½ã€å‹•çš„TOCè§£æã€ãƒãƒ«ãƒãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆå‡ºåŠ›å¯¾å¿œ
"""

import sys
import os
import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext
from pathlib import Path
import threading
import queue
import json
from datetime import datetime

# ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã‚µãƒãƒ¼ãƒˆ
try:
    from tkinterdnd2 import DND_FILES, TkinterDnD
    DND_SUPPORT = True
except ImportError:
    DND_SUPPORT = False

# v2.0ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
try:
    from epubsplit_word_toc_v2 import SplitEpubWordTOC, BatchProcessor
    V2_SUPPORT = True
except ImportError:
    V2_SUPPORT = False

# v3.0ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
try:
    from split_engine_v3 import (
        DynamicTOCAnalyzer, WordDocumentSplitter, MultiFormatExporter,
        SplitConfig, TOCEntry, WORD_SUPPORT, PDF_SUPPORT, EPUB_SUPPORT
    )
    V3_SUPPORT = True
except ImportError:
    V3_SUPPORT = False

class EpubTocGUIv3:
    """EPUBç›®æ¬¡è§£æãƒ„ãƒ¼ãƒ« GUIç‰ˆ v3.0"""
    
    def __init__(self, root):
        self.root = root
        self.root.title("ğŸ“š EPUBç›®æ¬¡è§£æãƒ„ãƒ¼ãƒ« v3.0 - åˆ†å‰²æ©Ÿèƒ½å¯¾å¿œ")
        self.root.geometry("900x800")
        self.root.configure(bg='#f0f0f0')
        
        # å¤‰æ•°
        self.processing = False
        self.queue = queue.Queue()
        self.batch_processor = None
        self.analyzer = None
        self.analysis_report = None
        
        # ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š
        self.setup_styles()
        
        # GUIä½œæˆ
        self.create_widgets()
        
        # ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—è¨­å®š
        if DND_SUPPORT:
            self.setup_drag_drop()
        
        # ã‚­ãƒ¥ãƒ¼ãƒã‚§ãƒƒã‚¯é–‹å§‹
        self.check_queue()
    
    def setup_styles(self):
        """ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š"""
        style = ttk.Style()
        style.theme_use('clam')
        
        # ã‚«ã‚¹ã‚¿ãƒ ã‚¹ã‚¿ã‚¤ãƒ«
        style.configure('Title.TLabel', font=('Arial', 16, 'bold'), foreground='#2c5aa0')
        style.configure('Header.TLabel', font=('Arial', 12, 'bold'), foreground='#444444')
        style.configure('Status.TLabel', font=('Arial', 10), foreground='#666666')
        style.configure('Success.TLabel', font=('Arial', 10), foreground='#0a7029')
        style.configure('Error.TLabel', font=('Arial', 10), foreground='#d32f2f')
    
    def create_widgets(self):
        """ã‚¦ã‚£ã‚¸ã‚§ãƒƒãƒˆä½œæˆ"""
        # ãƒ¡ã‚¤ãƒ³ãƒ•ãƒ¬ãƒ¼ãƒ 
        main_frame = ttk.Frame(self.root, padding="20")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # ã‚¿ã‚¤ãƒˆãƒ«
        title_label = ttk.Label(main_frame, 
                               text="ğŸ“š EPUBç›®æ¬¡è§£æãƒ„ãƒ¼ãƒ« v3.0", 
                               style='Title.TLabel')
        title_label.grid(row=0, column=0, columnspan=4, pady=(0, 20))
        
        # æ©Ÿèƒ½é¸æŠã‚¿ãƒ–
        self.notebook = ttk.Notebook(main_frame)
        self.notebook.grid(row=1, column=0, columnspan=4, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 15))
        
        # ã‚¿ãƒ–1: ç›®æ¬¡è§£æ
        self.create_analysis_tab()
        
        # ã‚¿ãƒ–2: åˆ†å‰²æ©Ÿèƒ½
        self.create_split_tab()
        
        # ã‚¿ãƒ–3: ãƒãƒƒãƒå‡¦ç†
        self.create_batch_tab()
        
        # å®Ÿè¡Œãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢
        button_frame = ttk.Frame(main_frame)
        button_frame.grid(row=2, column=0, columnspan=4, pady=(0, 15))\n        \n        self.process_button = ttk.Button(button_frame, text="ğŸš€ å®Ÿè¡Œ", \n                                        command=self.start_processing, \n                                        style='Accent.TButton')\n        self.process_button.pack(side=tk.LEFT, padx=(0, 10))\n        \n        self.stop_button = ttk.Button(button_frame, text=\"â¹ åœæ­¢\", \n                                     command=self.stop_processing, \n                                     state='disabled')\n        self.stop_button.pack(side=tk.LEFT)\n        \n        # ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼\n        self.progress = ttk.Progressbar(main_frame, mode='indeterminate')\n        self.progress.grid(row=3, column=0, columnspan=4, sticky=(tk.W, tk.E), pady=(0, 10))\n        \n        # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹\n        self.status_var = tk.StringVar(value=\"Ready\")\n        status_label = ttk.Label(main_frame, textvariable=self.status_var, style='Status.TLabel')\n        status_label.grid(row=4, column=0, columnspan=4)\n        \n        # ãƒ­ã‚°ã‚¨ãƒªã‚¢\n        log_frame = ttk.LabelFrame(main_frame, text=\"å‡¦ç†ãƒ­ã‚°\", padding=\"10\")\n        log_frame.grid(row=5, column=0, columnspan=4, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(15, 0))\n        \n        self.log_text = scrolledtext.ScrolledText(log_frame, width=100, height=15, \n                                                 font=('Consolas', 9))\n        self.log_text.pack(fill=tk.BOTH, expand=True)\n        \n        # ã‚°ãƒªãƒƒãƒ‰ã®é‡ã¿ã‚’è¨­å®š\n        self.root.columnconfigure(0, weight=1)\n        self.root.rowconfigure(0, weight=1)\n        main_frame.columnconfigure(1, weight=1)\n        main_frame.rowconfigure(1, weight=1)\n    \n    def create_analysis_tab(self):\n        \"\"\"ç›®æ¬¡è§£æã‚¿ãƒ–ã‚’ä½œæˆ\"\"\"\n        analysis_frame = ttk.Frame(self.notebook, padding=\"10\")\n        self.notebook.add(analysis_frame, text=\"ğŸ“Š ç›®æ¬¡è§£æ\")\n        \n        # ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ\n        file_frame = ttk.LabelFrame(analysis_frame, text=\"ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ\", padding=\"10\")\n        file_frame.grid(row=0, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 15))\n        \n        self.analysis_file_var = tk.StringVar()\n        file_entry = ttk.Entry(file_frame, textvariable=self.analysis_file_var, width=70)\n        file_entry.grid(row=0, column=0, padx=(0, 10))\n        \n        browse_btn = ttk.Button(file_frame, text=\"å‚ç…§\", command=self.browse_analysis_file)\n        browse_btn.grid(row=0, column=1)\n        \n        # ãƒ•ã‚¡ã‚¤ãƒ«ç¨®åˆ¥é¸æŠ\n        type_frame = ttk.LabelFrame(analysis_frame, text=\"ãƒ•ã‚¡ã‚¤ãƒ«ç¨®åˆ¥\", padding=\"10\")\n        type_frame.grid(row=1, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 15))\n        \n        self.file_type_var = tk.StringVar(value=\"auto\")\n        auto_radio = ttk.Radiobutton(type_frame, text=\"è‡ªå‹•åˆ¤å®š\", \n                                    variable=self.file_type_var, value=\"auto\")\n        auto_radio.grid(row=0, column=0, padx=(0, 20))\n        \n        word_radio = ttk.Radiobutton(type_frame, text=\"Wordãƒ•ã‚¡ã‚¤ãƒ«(.docx)\", \n                                    variable=self.file_type_var, value=\"word\")\n        word_radio.grid(row=0, column=1, padx=(0, 20))\n        \n        epub_radio = ttk.Radiobutton(type_frame, text=\"EPUBãƒ•ã‚¡ã‚¤ãƒ«(.epub)\", \n                                    variable=self.file_type_var, value=\"epub\")\n        epub_radio.grid(row=0, column=2)\n        \n        # è§£æçµæœè¡¨ç¤ºã‚¨ãƒªã‚¢\n        result_frame = ttk.LabelFrame(analysis_frame, text=\"è§£æçµæœ\", padding=\"10\")\n        result_frame.grid(row=2, column=0, columnspan=3, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 15))\n        \n        self.analysis_result_text = scrolledtext.ScrolledText(result_frame, width=80, height=15, \n                                                             font=('Consolas', 9))\n        self.analysis_result_text.pack(fill=tk.BOTH, expand=True)\n        \n        # é‡ã¿ã‚’è¨­å®š\n        analysis_frame.columnconfigure(1, weight=1)\n        analysis_frame.rowconfigure(2, weight=1)\n    \n    def create_split_tab(self):\n        \"\"\"åˆ†å‰²æ©Ÿèƒ½ã‚¿ãƒ–ã‚’ä½œæˆ\"\"\"\n        split_frame = ttk.Frame(self.notebook, padding=\"10\")\n        self.notebook.add(split_frame, text=\"âœ‚ï¸ åˆ†å‰²æ©Ÿèƒ½\")\n        \n        # åˆ†å‰²è¨­å®š\n        config_frame = ttk.LabelFrame(split_frame, text=\"åˆ†å‰²è¨­å®š\", padding=\"10\")\n        config_frame.grid(row=0, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 15))\n        \n        # åˆ†å‰²ãƒ¬ãƒ™ãƒ«\n        ttk.Label(config_frame, text=\"åˆ†å‰²ãƒ¬ãƒ™ãƒ«:\").grid(row=0, column=0, sticky=tk.W)\n        self.split_level_var = tk.StringVar(value=\"1\")\n        level_combo = ttk.Combobox(config_frame, textvariable=self.split_level_var, \n                                  values=[\"1\", \"2\", \"3\"], state=\"readonly\", width=10)\n        level_combo.grid(row=0, column=1, sticky=tk.W, padx=(10, 20))\n        \n        # å‡ºåŠ›å½¢å¼\n        ttk.Label(config_frame, text=\"å‡ºåŠ›å½¢å¼:\").grid(row=0, column=2, sticky=tk.W)\n        self.split_format_var = tk.StringVar(value=\"word\")\n        format_combo = ttk.Combobox(config_frame, textvariable=self.split_format_var, \n                                   values=[\"word\", \"pdf\", \"epub\"], state=\"readonly\", width=15)\n        format_combo.grid(row=0, column=3, sticky=tk.W, padx=(10, 0))\n        \n        # å‡ºåŠ›ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª\n        ttk.Label(config_frame, text=\"å‡ºåŠ›å…ˆ:\").grid(row=1, column=0, sticky=tk.W, pady=(10, 0))\n        self.split_output_var = tk.StringVar(value=\"output_split\")\n        output_entry = ttk.Entry(config_frame, textvariable=self.split_output_var, width=50)\n        output_entry.grid(row=1, column=1, columnspan=2, sticky=(tk.W, tk.E), padx=(10, 10), pady=(10, 0))\n        \n        output_browse = ttk.Button(config_frame, text=\"å‚ç…§\", command=self.browse_split_output)\n        output_browse.grid(row=1, column=3, pady=(10, 0))\n        \n        # è©³ç´°ã‚ªãƒ—ã‚·ãƒ§ãƒ³\n        option_frame = ttk.LabelFrame(split_frame, text=\"è©³ç´°ã‚ªãƒ—ã‚·ãƒ§ãƒ³\", padding=\"10\")\n        option_frame.grid(row=1, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 15))\n        \n        self.preserve_formatting_var = tk.BooleanVar(value=True)\n        format_check = ttk.Checkbutton(option_frame, text=\"æ›¸å¼ã‚’ä¿æŒ\", \n                                      variable=self.preserve_formatting_var)\n        format_check.grid(row=0, column=0, sticky=tk.W)\n        \n        self.include_subsections_var = tk.BooleanVar(value=True)\n        subsection_check = ttk.Checkbutton(option_frame, text=\"ä¸‹ä½ãƒ¬ãƒ™ãƒ«ã‚‚å«ã‚ã‚‹\", \n                                          variable=self.include_subsections_var)\n        subsection_check.grid(row=0, column=1, sticky=tk.W, padx=(20, 0))\n        \n        # ãƒ•ã‚¡ã‚¤ãƒ«åãƒ‘ã‚¿ãƒ¼ãƒ³\n        ttk.Label(option_frame, text=\"ãƒ•ã‚¡ã‚¤ãƒ«åãƒ‘ã‚¿ãƒ¼ãƒ³:\").grid(row=1, column=0, sticky=tk.W, pady=(10, 0))\n        self.filename_pattern_var = tk.StringVar(value=\"{index:02d}_{title}\")\n        pattern_entry = ttk.Entry(option_frame, textvariable=self.filename_pattern_var, width=40)\n        pattern_entry.grid(row=1, column=1, sticky=tk.W, padx=(10, 0), pady=(10, 0))\n        \n        # åˆ†å‰²ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼\n        preview_frame = ttk.LabelFrame(split_frame, text=\"åˆ†å‰²ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼\", padding=\"10\")\n        preview_frame.grid(row=2, column=0, columnspan=3, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 15))\n        \n        self.split_preview_text = scrolledtext.ScrolledText(preview_frame, width=80, height=12, \n                                                           font=('Consolas', 9))\n        self.split_preview_text.pack(fill=tk.BOTH, expand=True)\n        \n        # é‡ã¿ã‚’è¨­å®š\n        split_frame.columnconfigure(1, weight=1)\n        split_frame.rowconfigure(2, weight=1)\n    \n    def create_batch_tab(self):\n        \"\"\"ãƒãƒƒãƒå‡¦ç†ã‚¿ãƒ–ã‚’ä½œæˆ\"\"\"\n        batch_frame = ttk.Frame(self.notebook, padding=\"10\")\n        self.notebook.add(batch_frame, text=\"ğŸ”„ ãƒãƒƒãƒå‡¦ç†\")\n        \n        # ãƒ•ã‚©ãƒ«ãƒ€é¸æŠ\n        folder_frame = ttk.LabelFrame(batch_frame, text=\"ãƒ•ã‚©ãƒ«ãƒ€é¸æŠ\", padding=\"10\")\n        folder_frame.grid(row=0, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 15))\n        \n        self.batch_folder_var = tk.StringVar()\n        folder_entry = ttk.Entry(folder_frame, textvariable=self.batch_folder_var, width=70)\n        folder_entry.grid(row=0, column=0, padx=(0, 10))\n        \n        folder_browse = ttk.Button(folder_frame, text=\"å‚ç…§\", command=self.browse_batch_folder)\n        folder_browse.grid(row=0, column=1)\n        \n        # ãƒãƒƒãƒå‡¦ç†è¨­å®š\n        batch_config_frame = ttk.LabelFrame(batch_frame, text=\"ãƒãƒƒãƒå‡¦ç†è¨­å®š\", padding=\"10\")\n        batch_config_frame.grid(row=1, column=0, columnspan=3, sticky=(tk.W, tk.E), pady=(0, 15))\n        \n        ttk.Label(batch_config_frame, text=\"ä¸¦åˆ—å®Ÿè¡Œæ•°:\").grid(row=0, column=0, sticky=tk.W)\n        self.workers_var = tk.StringVar(value=\"4\")\n        workers_spin = ttk.Spinbox(batch_config_frame, from_=1, to=8, \n                                  textvariable=self.workers_var, width=10)\n        workers_spin.grid(row=0, column=1, sticky=tk.W, padx=(10, 20))\n        \n        self.recursive_var = tk.BooleanVar(value=True)\n        recursive_check = ttk.Checkbutton(batch_config_frame, text=\"ã‚µãƒ–ãƒ•ã‚©ãƒ«ãƒ€ã‚‚æ¤œç´¢\", \n                                         variable=self.recursive_var)\n        recursive_check.grid(row=0, column=2, padx=(0, 20))\n        \n        # å‡¦ç†ç¨®åˆ¥\n        ttk.Label(batch_config_frame, text=\"å‡¦ç†ç¨®åˆ¥:\").grid(row=1, column=0, sticky=tk.W, pady=(10, 0))\n        self.batch_mode_var = tk.StringVar(value=\"analysis\")\n        \n        analysis_radio = ttk.Radiobutton(batch_config_frame, text=\"ç›®æ¬¡è§£æã®ã¿\", \n                                        variable=self.batch_mode_var, value=\"analysis\")\n        analysis_radio.grid(row=1, column=1, sticky=tk.W, padx=(10, 0), pady=(10, 0))\n        \n        split_radio = ttk.Radiobutton(batch_config_frame, text=\"åˆ†å‰²å‡¦ç†ã‚‚å®Ÿè¡Œ\", \n                                     variable=self.batch_mode_var, value=\"split\")\n        split_radio.grid(row=1, column=2, sticky=tk.W, pady=(10, 0))\n        \n        # ãƒãƒƒãƒçµæœ\n        batch_result_frame = ttk.LabelFrame(batch_frame, text=\"ãƒãƒƒãƒå‡¦ç†çµæœ\", padding=\"10\")\n        batch_result_frame.grid(row=2, column=0, columnspan=3, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 15))\n        \n        self.batch_result_text = scrolledtext.ScrolledText(batch_result_frame, width=80, height=12, \n                                                          font=('Consolas', 9))\n        self.batch_result_text.pack(fill=tk.BOTH, expand=True)\n        \n        # é‡ã¿ã‚’è¨­å®š\n        batch_frame.columnconfigure(1, weight=1)\n        batch_frame.rowconfigure(2, weight=1)\n    \n    def setup_drag_drop(self):\n        \"\"\"ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã®è¨­å®š\"\"\"\n        self.root.drop_target_register(DND_FILES)\n        self.root.dnd_bind('<<Drop>>', self.on_drop)\n    \n    def on_drop(self, event):\n        \"\"\"ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—å‡¦ç†\"\"\"\n        files = self.root.tk.splitlist(event.data)\n        if files:\n            file_path = Path(files[0])\n            if file_path.is_file():\n                if file_path.suffix.lower() in ['.docx', '.epub']:\n                    # ç¾åœ¨ã®ã‚¿ãƒ–ã«å¿œã˜ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¨­å®š\n                    current_tab = self.notebook.index(self.notebook.select())\n                    if current_tab == 0:  # ç›®æ¬¡è§£æã‚¿ãƒ–\n                        self.analysis_file_var.set(str(file_path))\n                    else:\n                        self.analysis_file_var.set(str(file_path))\n                else:\n                    messagebox.showwarning(\"è­¦å‘Š\", \"Wordãƒ•ã‚¡ã‚¤ãƒ«ã¾ãŸã¯EPUBãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„\")\n            elif file_path.is_dir():\n                self.batch_folder_var.set(str(file_path))\n                self.notebook.select(2)  # ãƒãƒƒãƒå‡¦ç†ã‚¿ãƒ–ã«åˆ‡ã‚Šæ›¿ãˆ\n    \n    def browse_analysis_file(self):\n        \"\"\"è§£æãƒ•ã‚¡ã‚¤ãƒ«ã®é¸æŠ\"\"\"\n        file_path = filedialog.askopenfilename(\n            title=\"è§£æãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ\",\n            filetypes=[\n                (\"å¯¾å¿œãƒ•ã‚¡ã‚¤ãƒ«\", \"*.docx;*.epub\"),\n                (\"Word files\", \"*.docx\"), \n                (\"EPUB files\", \"*.epub\"), \n                (\"All files\", \"*.*\")\n            ]\n        )\n        if file_path:\n            self.analysis_file_var.set(file_path)\n    \n    def browse_split_output(self):\n        \"\"\"åˆ†å‰²å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€ã®é¸æŠ\"\"\"\n        folder_path = filedialog.askdirectory(title=\"åˆ†å‰²å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠ\")\n        if folder_path:\n            self.split_output_var.set(folder_path)\n    \n    def browse_batch_folder(self):\n        \"\"\"ãƒãƒƒãƒå‡¦ç†ãƒ•ã‚©ãƒ«ãƒ€ã®é¸æŠ\"\"\"\n        folder_path = filedialog.askdirectory(title=\"ãƒãƒƒãƒå‡¦ç†ãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠ\")\n        if folder_path:\n            self.batch_folder_var.set(folder_path)\n    \n    def start_processing(self):\n        \"\"\"å‡¦ç†é–‹å§‹\"\"\"\n        if not V3_SUPPORT:\n            messagebox.showerror(\"ã‚¨ãƒ©ãƒ¼\", \"v3.0ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“\")\n            return\n        \n        current_tab = self.notebook.index(self.notebook.select())\n        \n        if current_tab == 0:  # ç›®æ¬¡è§£æ\n            self.start_analysis()\n        elif current_tab == 1:  # åˆ†å‰²æ©Ÿèƒ½\n            self.start_split()\n        elif current_tab == 2:  # ãƒãƒƒãƒå‡¦ç†\n            self.start_batch()\n    \n    def start_analysis(self):\n        \"\"\"ç›®æ¬¡è§£æé–‹å§‹\"\"\"\n        file_path = self.analysis_file_var.get().strip()\n        if not file_path or not Path(file_path).exists():\n            messagebox.showwarning(\"è­¦å‘Š\", \"æœ‰åŠ¹ãªãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„\")\n            return\n        \n        self.set_processing_state(True)\n        self.log(\"ğŸ” ç›®æ¬¡è§£æã‚’é–‹å§‹ã—ã¦ã„ã¾ã™...\")\n        \n        # åˆ¥ã‚¹ãƒ¬ãƒƒãƒ‰ã§è§£æå®Ÿè¡Œ\n        thread = threading.Thread(target=self.process_analysis, args=(file_path,), daemon=True)\n        thread.start()\n    \n    def start_split(self):\n        \"\"\"åˆ†å‰²å‡¦ç†é–‹å§‹\"\"\"\n        if not self.analysis_report:\n            messagebox.showwarning(\"è­¦å‘Š\", \"æœ€åˆã«ç›®æ¬¡è§£æã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„\")\n            self.notebook.select(0)  # è§£æã‚¿ãƒ–ã«åˆ‡ã‚Šæ›¿ãˆ\n            return\n        \n        self.set_processing_state(True)\n        self.log(\"âœ‚ï¸ åˆ†å‰²å‡¦ç†ã‚’é–‹å§‹ã—ã¦ã„ã¾ã™...\")\n        \n        # åˆ¥ã‚¹ãƒ¬ãƒƒãƒ‰ã§åˆ†å‰²å®Ÿè¡Œ\n        thread = threading.Thread(target=self.process_split, daemon=True)\n        thread.start()\n    \n    def start_batch(self):\n        \"\"\"ãƒãƒƒãƒå‡¦ç†é–‹å§‹\"\"\"\n        folder_path = self.batch_folder_var.get().strip()\n        if not folder_path or not Path(folder_path).exists():\n            messagebox.showwarning(\"è­¦å‘Š\", \"æœ‰åŠ¹ãªãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠã—ã¦ãã ã•ã„\")\n            return\n        \n        self.set_processing_state(True)\n        self.log(\"ğŸ”„ ãƒãƒƒãƒå‡¦ç†ã‚’é–‹å§‹ã—ã¦ã„ã¾ã™...\")\n        \n        # åˆ¥ã‚¹ãƒ¬ãƒƒãƒ‰ã§ãƒãƒƒãƒå®Ÿè¡Œ\n        thread = threading.Thread(target=self.process_batch, args=(folder_path,), daemon=True)\n        thread.start()\n    \n    def process_analysis(self, file_path):\n        \"\"\"ç›®æ¬¡è§£æå‡¦ç†ï¼ˆåˆ¥ã‚¹ãƒ¬ãƒƒãƒ‰ï¼‰\"\"\"\n        try:\n            self.analyzer = DynamicTOCAnalyzer()\n            \n            # ãƒ•ã‚¡ã‚¤ãƒ«ç¨®åˆ¥åˆ¤å®š\n            file_type = self.file_type_var.get()\n            if file_type == \"auto\":\n                file_type = \"word\" if file_path.endswith('.docx') else \"epub\"\n            \n            self.queue.put((\"log\", f\"ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«: {Path(file_path).name}\"))\n            self.queue.put((\"log\", f\"ğŸ“Š ç¨®åˆ¥: {file_type.upper()}ãƒ•ã‚¡ã‚¤ãƒ«\"))\n            \n            # è§£æå®Ÿè¡Œ\n            if file_type == \"word\":\n                self.analysis_report = self.analyzer.analyze_word_document(file_path)\n            else:\n                self.analysis_report = self.analyzer.analyze_epub_toc(file_path)\n            \n            # çµæœè¡¨ç¤º\n            result_text = self.format_analysis_result(self.analysis_report)\n            self.queue.put((\"analysis_result\", result_text))\n            self.queue.put((\"log\", \"âœ… ç›®æ¬¡è§£æå®Œäº†ï¼\"))\n            self.queue.put((\"complete\", \"ç›®æ¬¡è§£æãŒå®Œäº†ã—ã¾ã—ãŸ\"))\n            \n        except Exception as e:\n            self.queue.put((\"error\", f\"è§£æã‚¨ãƒ©ãƒ¼: {str(e)}\"))\n        finally:\n            self.queue.put((\"finished\", None))\n    \n    def process_split(self):\n        \"\"\"åˆ†å‰²å‡¦ç†ï¼ˆåˆ¥ã‚¹ãƒ¬ãƒƒãƒ‰ï¼‰\"\"\"\n        try:\n            file_path = self.analysis_file_var.get()\n            \n            # åˆ†å‰²è¨­å®šä½œæˆ\n            config = SplitConfig(\n                split_level=int(self.split_level_var.get()),\n                output_format=self.split_format_var.get(),\n                output_dir=self.split_output_var.get(),\n                filename_pattern=self.filename_pattern_var.get(),\n                preserve_formatting=self.preserve_formatting_var.get(),\n                include_subsections=self.include_subsections_var.get()\n            )\n            \n            self.queue.put((\"log\", f\"âš™ï¸ åˆ†å‰²ãƒ¬ãƒ™ãƒ«: {config.split_level}\"))\n            self.queue.put((\"log\", f\"ğŸ“„ å‡ºåŠ›å½¢å¼: {config.output_format}\"))\n            self.queue.put((\"log\", f\"ğŸ“ å‡ºåŠ›å…ˆ: {config.output_dir}\"))\n            \n            if config.output_format == \"word\":\n                # Wordåˆ†å‰²\n                splitter = WordDocumentSplitter(self.analyzer)\n                output_files = splitter.split_document(file_path, config)\n                \n                self.queue.put((\"log\", f\"âœ… {len(output_files)}å€‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆã—ã¾ã—ãŸ\"))\n                for i, file_path in enumerate(output_files, 1):\n                    self.queue.put((\"log\", f\"  {i}. {Path(file_path).name}\"))\n            \n            else:\n                # ãã®ä»–å½¢å¼ï¼ˆPDFã€EPUBï¼‰\n                self.queue.put((\"log\", \"ğŸš§ PDF/EPUBå‡ºåŠ›ã¯é–‹ç™ºä¸­ã§ã™\"))\n            \n            self.queue.put((\"complete\", \"åˆ†å‰²å‡¦ç†ãŒå®Œäº†ã—ã¾ã—ãŸ\"))\n            \n        except Exception as e:\n            self.queue.put((\"error\", f\"åˆ†å‰²ã‚¨ãƒ©ãƒ¼: {str(e)}\"))\n        finally:\n            self.queue.put((\"finished\", None))\n    \n    def process_batch(self, folder_path):\n        \"\"\"ãƒãƒƒãƒå‡¦ç†ï¼ˆåˆ¥ã‚¹ãƒ¬ãƒƒãƒ‰ï¼‰\"\"\"\n        try:\n            self.queue.put((\"log\", f\"ğŸ“ å‡¦ç†ãƒ•ã‚©ãƒ«ãƒ€: {folder_path}\"))\n            \n            # å¯¾å¿œãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œç´¢\n            folder = Path(folder_path)\n            patterns = ['*.docx', '*.epub']\n            files = []\n            \n            for pattern in patterns:\n                if self.recursive_var.get():\n                    files.extend(folder.rglob(pattern))\n                else:\n                    files.extend(folder.glob(pattern))\n            \n            self.queue.put((\"log\", f\"ğŸ“š {len(files)}å€‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ¤œå‡º\"))\n            \n            if not files:\n                self.queue.put((\"error\", \"å‡¦ç†å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“\"))\n                return\n            \n            # å„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‡¦ç†\n            success_count = 0\n            error_count = 0\n            \n            for i, file_path in enumerate(files, 1):\n                try:\n                    self.queue.put((\"log\", f\"[{i}/{len(files)}] {file_path.name}\"))\n                    \n                    analyzer = DynamicTOCAnalyzer()\n                    if file_path.suffix.lower() == '.docx':\n                        report = analyzer.analyze_word_document(str(file_path))\n                    else:\n                        report = analyzer.analyze_epub_toc(str(file_path))\n                    \n                    self.queue.put((\"log\", f\"  ğŸ“Š ç›®æ¬¡ã‚¨ãƒ³ãƒˆãƒª: {report['total_entries']}å€‹\"))\n                    self.queue.put((\"log\", f\"  ğŸ¯ æ¨å¥¨åˆ†å‰²ãƒ¬ãƒ™ãƒ«: {report['recommended_split_level']}\"))\n                    \n                    success_count += 1\n                    \n                except Exception as e:\n                    self.queue.put((\"log\", f\"  âŒ ã‚¨ãƒ©ãƒ¼: {str(e)}\"))\n                    error_count += 1\n            \n            self.queue.put((\"log\", f\"\\nğŸ“Š ãƒãƒƒãƒå‡¦ç†å®Œäº†:\"))\n            self.queue.put((\"log\", f\"  âœ… æˆåŠŸ: {success_count}ãƒ•ã‚¡ã‚¤ãƒ«\"))\n            self.queue.put((\"log\", f\"  âŒ ã‚¨ãƒ©ãƒ¼: {error_count}ãƒ•ã‚¡ã‚¤ãƒ«\"))\n            \n            self.queue.put((\"complete\", f\"ãƒãƒƒãƒå‡¦ç†å®Œäº†ï¼ˆ{success_count}ä»¶æˆåŠŸï¼‰\"))\n            \n        except Exception as e:\n            self.queue.put((\"error\", f\"ãƒãƒƒãƒå‡¦ç†ã‚¨ãƒ©ãƒ¼: {str(e)}\"))\n        finally:\n            self.queue.put((\"finished\", None))\n    \n    def format_analysis_result(self, report):\n        \"\"\"è§£æçµæœã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ\"\"\"\n        result = []\n        result.append(\"ğŸ“Š ç›®æ¬¡æ§‹é€ è§£æçµæœ\")\n        result.append(\"=\" * 50)\n        result.append(f\"ç·ã‚¨ãƒ³ãƒˆãƒªæ•°: {report['total_entries']}å€‹\")\n        result.append(f\"æœ€å¤§éšå±¤æ·±åº¦: {report['max_depth']}ãƒ¬ãƒ™ãƒ«\")\n        result.append(f\"æ¨å¥¨åˆ†å‰²ãƒ¬ãƒ™ãƒ«: {report['recommended_split_level']}\")\n        result.append(\"\")\n        \n        result.append(\"ğŸ“‹ ãƒ¬ãƒ™ãƒ«åˆ¥çµ±è¨ˆ:\")\n        for level, count in report['level_stats'].items():\n            result.append(f\"  ãƒ¬ãƒ™ãƒ«{level}: {count}å€‹\")\n        result.append(\"\")\n        \n        result.append(\"ğŸ” åˆ†å‰²ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼:\")\n        for i, section in enumerate(report['split_preview'], 1):\n            result.append(f\"{i}. {section['title']}\")\n            if section['subsections'] > 0:\n                result.append(f\"   â”” ã‚µãƒ–ã‚»ã‚¯ã‚·ãƒ§ãƒ³: {section['subsections']}å€‹\")\n                for sub in section['subsection_list']:\n                    result.append(f\"     â€¢ {sub}\")\n        \n        return \"\\n\".join(result)\n    \n    def stop_processing(self):\n        \"\"\"å‡¦ç†åœæ­¢\"\"\"\n        self.processing = False\n        self.queue.put((\"log\", \"â¹ å‡¦ç†ã‚’åœæ­¢ã—ã¾ã—ãŸ\"))\n        self.queue.put((\"finished\", None))\n    \n    def set_processing_state(self, processing):\n        \"\"\"å‡¦ç†çŠ¶æ…‹ã®è¨­å®š\"\"\"\n        self.processing = processing\n        if processing:\n            self.process_button.configure(state='disabled')\n            self.stop_button.configure(state='normal')\n            self.progress.configure(mode='indeterminate')\n            self.progress.start()\n            self.status_var.set(\"å‡¦ç†ä¸­...\")\n        else:\n            self.process_button.configure(state='normal')\n            self.stop_button.configure(state='disabled')\n            self.progress.stop()\n            self.progress.configure(mode='determinate', value=0)\n            self.status_var.set(\"Ready\")\n    \n    def check_queue(self):\n        \"\"\"ã‚­ãƒ¥ãƒ¼ãƒã‚§ãƒƒã‚¯\"\"\"\n        try:\n            while True:\n                msg_type, msg_data = self.queue.get_nowait()\n                \n                if msg_type == \"log\":\n                    self.log(msg_data)\n                elif msg_type == \"analysis_result\":\n                    self.analysis_result_text.delete(1.0, tk.END)\n                    self.analysis_result_text.insert(tk.END, msg_data)\n                elif msg_type == \"complete\":\n                    self.status_var.set(msg_data)\n                    messagebox.showinfo(\"å®Œäº†\", msg_data)\n                elif msg_type == \"error\":\n                    self.status_var.set(msg_data)\n                    messagebox.showerror(\"ã‚¨ãƒ©ãƒ¼\", msg_data)\n                elif msg_type == \"finished\":\n                    self.set_processing_state(False)\n                    break\n                    \n        except queue.Empty:\n            pass\n        \n        # 100mså¾Œã«å†ãƒã‚§ãƒƒã‚¯\n        self.root.after(100, self.check_queue)\n    \n    def log(self, message):\n        \"\"\"ãƒ­ã‚°å‡ºåŠ›\"\"\"\n        timestamp = datetime.now().strftime(\"%H:%M:%S\")\n        log_message = f\"[{timestamp}] {message}\\n\"\n        self.log_text.insert(tk.END, log_message)\n        self.log_text.see(tk.END)\n        self.root.update_idletasks()\n\ndef main():\n    \"\"\"ãƒ¡ã‚¤ãƒ³é–¢æ•°\"\"\"\n    # Tkinterãƒ«ãƒ¼ãƒˆã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ä½œæˆ\n    if DND_SUPPORT:\n        root = TkinterDnD.Tk()\n    else:\n        root = tk.Tk()\n        print(\"âš ï¸ tkinterdnd2ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã¯ç„¡åŠ¹ã§ã™ã€‚\")\n    \n    try:\n        # GUIä½œæˆ\n        app = EpubTocGUIv3(root)\n        \n        # ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’ä¸­å¤®ã«é…ç½®\n        root.update_idletasks()\n        x = (root.winfo_screenwidth() // 2) - (root.winfo_width() // 2)\n        y = (root.winfo_screenheight() // 2) - (root.winfo_height() // 2)\n        root.geometry(f\"+{x}+{y}\")\n        \n        # ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—é–‹å§‹\n        root.mainloop()\n        \n    except Exception as e:\n        messagebox.showerror(\"èµ·å‹•ã‚¨ãƒ©ãƒ¼\", f\"ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ:\\n{str(e)}\")\n\nif __name__ == \"__main__\":\n    main()\n